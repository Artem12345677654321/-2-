<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLATO RUG | Digital Veil</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;1,400&family=Syncopate:wght@400;700&family=Montserrat:wght@300;400;500&display=swap" rel="stylesheet">

    <style>
        :root {
            --color-bg: #050505;
            --color-text: #e0e0e0;
            --color-gold: #D4AF37;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--color-bg);
            color: var(--color-text);
            font-family: 'Montserrat', sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            cursor: none;
        }

        /* === 3D Canvas (Rug) - Z-Index: 1 === */
        #webgl-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        /* === Digital Veil Canvas (Shader Mask) - Z-Index: 10 === */
        /* Этот Canvas всегда покрывает сцену, и через него "прорезается" дыра */
        #veil-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10; 
            pointer-events: none; /* Пропускаем клики */
        }

        /* === UI Layer - Z-Index: 11 === */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 11; 
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s;
        }
        
        /* === PRELOADER (Digital Loom) - Z-Index: 5000+ === */
        #loader-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 5000;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        /* (Сохраняем стили лоадера из V3 для консистентности) */
        .loader-title {
            font-family: 'Syncopate', sans-serif;
            font-weight: 700;
            font-size: 4rem;
            letter-spacing: -0.05em;
            color: transparent;
            -webkit-text-stroke: 1px rgba(255,255,255,0.8);
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        .loader-title::after {
            content: attr(data-text);
            position: absolute;
            top: 0; left: 0;
            width: 0%;
            height: 100%;
            color: var(--color-gold);
            -webkit-text-stroke: 0px;
            overflow: hidden;
            white-space: nowrap;
        }
        .loader-status {
            font-family: 'Cormorant Garamond', serif;
            font-style: italic;
            font-size: 1.2rem;
            color: rgba(255,255,255,0.5);
            margin-top: 10px;
            letter-spacing: 0.1em;
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        .tech-data {
            font-family: 'Courier New', monospace;
            font-size: 0.7rem;
            color: var(--color-gold);
            opacity: 0.7;
            text-transform: uppercase;
        }

        /* === CURSOR === */
        .cursor-dot {
            position: fixed; top: 0; left: 0; width: 6px; height: 6px;
            background-color: var(--color-gold); border-radius: 50%;
            z-index: 10000; pointer-events: none; mix-blend-mode: difference;
        }
        .cursor-circle {
            position: fixed; top: 0; left: 0; width: 40px; height: 40px;
            border: 1px solid rgba(212, 175, 55, 0.3); border-radius: 50%;
            z-index: 10000; pointer-events: none; transition: transform 0.1s;
        }

        /* === UI STYLES === */
        nav {
            position: absolute; top: 50px; width: 100%; padding: 0 80px;
            display: flex; justify-content: space-between; align-items: flex-start;
        }
        .logo-mark {
            font-family: 'Syncopate', sans-serif; font-weight: 700;
            font-size: 1.2rem; letter-spacing: 0.2em; color: #fff;
        }
        .nav-links span {
            font-family: 'Montserrat', sans-serif; font-size: 0.8rem;
            letter-spacing: 0.1em; margin-bottom: 8px; 
            color: rgba(255,255,255,0.6); cursor: none;
            pointer-events: auto; transition: color 0.3s;
        }
        .nav-links span:hover { color: var(--color-gold); }
        .hero-content {
            position: absolute; bottom: 80px; left: 80px; max-width: 600px;
        }
        h1 {
            font-family: 'Cormorant Garamond', serif; font-size: 6vw;
            line-height: 0.9; color: #fff; margin-bottom: 20px;
        }
        h1 i {
            font-family: 'Cormorant Garamond', serif; font-weight: 300;
            color: var(--color-gold);
        }
        .hero-desc {
            font-size: 1rem; line-height: 1.6; color: rgba(255,255,255,0.7);
            border-left: 1px solid var(--color-gold); padding-left: 20px;
            margin-top: 30px;
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.1/",
    "react/": "https://aistudiocdn.com/react@^19.2.1/",
    "three": "https://aistudiocdn.com/three@^0.181.2",
    "gsap": "https://aistudiocdn.com/gsap@^3.13.0",
    "gsap/": "https://aistudiocdn.com/gsap@^3.13.0/"
  }
}
</script>
</head>
<body>

    <div class="cursor-dot"></div>
    <div class="cursor-circle"></div>

    <canvas id="webgl-canvas"></canvas>

    <canvas id="veil-canvas"></canvas>

    <div id="ui-layer">
        <nav>
            <div class="logo-mark">PLATO</div>
            <div class="nav-links">
                <span>COLLECTION 2025</span>
                <span>BESPOKE STUDIO</span>
                <span>THE ATELIER</span>
            </div>
        </nav>
        <div class="hero-content">
            <h1>Weaving <br> <i>Silence & Time</i></h1>
            <p class="hero-desc">
                Процедурная генерация текстур ручной работы.<br>
                Каждая нить уникальна. Искусство цифрового ремесла.
            </p>
        </div>
    </div>
    
    <div id="loader-container">
        <div class="loader-content">
            <div class="loader-title" data-text="PLATO">PLATO</div>
            <div class="loader-status">
                <span id="loader-phase">INITIALIZING LOOM</span>
            </div>
            <div class="tech-data">
                <span id="kpsi-counter">0000</span> KNOTS / SQ.INCH
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // ==========================================
        // 1. GLOBAL SETUP AND CURSOR
        // ==========================================
        const cursorDot = document.querySelector('.cursor-dot');
        const cursorCircle = document.querySelector('.cursor-circle');
        let mouse = new THREE.Vector2(0.5, 0.5); // Normalized mouse position (0 to 1)

        window.addEventListener('mousemove', (e) => {
            // Update cursor DOM elements
            gsap.to(cursorDot, { x: e.clientX - 3, y: e.clientY - 3, duration: 0.1 });
            gsap.to(cursorCircle, { x: e.clientX - 20, y: e.clientY - 20, duration: 0.4 });
            
            // Update normalized mouse position for the shader (Y is inverted in WebGL from top-left DOM)
            mouse.x = e.clientX / window.innerWidth;
            mouse.y = 1.0 - (e.clientY / window.innerHeight); 
        });


        // ==========================================
        // 2. RUG SCENE (WEBGL 1 - BACKGROUND)
        // ==========================================
        const rugCanvas = document.getElementById('webgl-canvas');
        const rScene = new THREE.Scene();
        const rCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        rCamera.position.set(0, 30, 0); 
        rCamera.lookAt(0, 0, 0);

        const rRenderer = new THREE.WebGLRenderer({ canvas: rugCanvas, antialias: true, alpha: true });
        rRenderer.setSize(window.innerWidth, window.innerHeight);
        rRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        rRenderer.shadowMap.enabled = true;
        rRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
        rRenderer.toneMapping = THREE.ACESFilmicToneMapping;

        // --- Rug Generation (Procedural) ---
        function createRugTexture() {
            const size = 1024;
            const ctx = document.createElement('canvas').getContext('2d');
            ctx.canvas.width = size;
            ctx.canvas.height = size;
            ctx.fillStyle = '#6e6e6e'; ctx.fillRect(0, 0, size, size);
            
            for (let i = 0; i < 60000; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const grey = Math.floor(Math.random() * 60 + 80);
                ctx.fillStyle = `rgba(${grey},${grey},${grey}, 0.15)`;
                ctx.fillRect(x, y, 2, 2);
            }
            const texture = new THREE.CanvasTexture(ctx.canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 2); 
            return texture;
        }

        const rugTexture = createRugTexture();
        const rGeometry = new THREE.PlaneGeometry(5, 7, 200, 200);
        const rMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff, map: rugTexture, displacementMap: rugTexture,
            displacementScale: 0.2, roughness: 0.8, normalMap: rugTexture,
            normalScale: new THREE.Vector2(1, 1)
        });

        const rug = new THREE.Mesh(rGeometry, rMaterial);
        rug.rotation.x = -Math.PI / 2;
        rug.receiveShadow = true;
        rug.castShadow = true;
        rScene.add(rug);

        // --- Lighting ---
        rScene.add(new THREE.AmbientLight(0xffffff, 0.2));
        const spotLight = new THREE.SpotLight(0xffeeb1, 2.5);
        spotLight.position.set(5, 12, 5);
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 2048;
        spotLight.shadow.mapSize.height = 2048;
        spotLight.shadow.bias = -0.0001;
        rScene.add(spotLight);

        // --- Loop ---
        const clock = new THREE.Clock();
        function animateRugScene() {
            requestAnimationFrame(animateRugScene);
            const t = clock.getElapsedTime();
            rug.position.y = Math.sin(t * 0.3) * 0.02; // Breathing effect
            rRenderer.render(rScene, rCamera);
        }
        animateRugScene();

        // ==========================================
        // 3. DIGITAL VEIL (WEBGL 2 - MASKING LAYER)
        // ==========================================
        const veilCanvas = document.getElementById('veil-canvas');
        const vScene = new THREE.Scene();
        const vCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        vCamera.position.z = 1;
        
        const vRenderer = new THREE.WebGLRenderer({ canvas: veilCanvas, antialias: true, alpha: true });
        vRenderer.setSize(window.innerWidth, window.innerHeight);
        vRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // --- GLSL SHADERS (The Core of the Effect) ---
        
        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform vec2 u_mouse;
            uniform float u_time;
            uniform float u_reveal_radius;
            uniform vec2 u_flash_pos;
            uniform float u_flash_radius;
            
            varying vec2 vUv;
            
            void main() {
                // 1. Mouse Reveal Mask
                float dist_mouse = distance(vUv, u_mouse);
                // softstep(edge0, edge1, x): Returns 0.0 if x is less than edge0, 1.0 if x is greater than edge1, and smoothly interpolates between edge0 and edge1.
                // Since vUv is 0-1, we use a small normalized radius. 0.1 = 10% of screen.
                float mouse_mask = smoothstep(u_reveal_radius, u_reveal_radius + 0.1, dist_mouse); 

                // 2. Random Flash Mask (u_flash_radius is animated from 0 to large and back)
                float dist_flash = distance(vUv, u_flash_pos);
                // Flash is transparent inside its radius, opaque outside.
                float flash_mask = smoothstep(u_flash_radius, u_flash_radius - 0.05, dist_flash);

                // 3. Combine Masks: max() means if EITHER mask reveals, the veil is removed.
                float total_mask = max(mouse_mask, 1.0 - flash_mask);

                // Final veil color (Black with opacity controlled by the mask)
                // total_mask=1.0 means full veil (black). total_mask=0.0 means full transparency.
                gl_FragColor = vec4(vec3(0.0), total_mask);
            }
        `;

        const veilUniforms = {
            u_mouse: { value: mouse },
            u_time: { value: 0.0 },
            u_reveal_radius: { value: 0.12 }, // Base radius of the mouse effect
            u_flash_pos: { value: new THREE.Vector2(0.5, 0.5) },
            u_flash_radius: { value: 0.0 } // Animated radius of the flash
        };

        const veilMaterial = new THREE.ShaderMaterial({
            uniforms: veilUniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            depthWrite: false
        });

        const plane = new THREE.PlaneGeometry(2, 2);
        const veilMesh = new THREE.Mesh(plane, veilMaterial);
        vScene.add(veilMesh);

        // --- Loop for Veil ---
        function animateVeilScene() {
            requestAnimationFrame(animateVeilScene);
            veilUniforms.u_time.value += 0.01;
            veilUniforms.u_mouse.value = mouse;
            vRenderer.render(vScene, vCamera);
        }
        animateVeilScene();

        // ==========================================
        // 4. RANDOM FLASH MECHANISM (P-39)
        // ==========================================

        function triggerRandomFlash() {
            // Random position for the flash (normalized 0-1)
            const randomX = Math.random() * 0.6 + 0.2; // Keep away from edges
            const randomY = Math.random() * 0.6 + 0.2;
            
            // Set the flash starting point
            veilUniforms.u_flash_pos.value.set(randomX, randomY);
            veilUniforms.u_flash_radius.value = 0.0;
            
            // GSAP Timeline for the flash effect
            gsap.timeline({
                // After the flash ends, schedule the next one
                onComplete: scheduleNextFlash
            })
            // Flash out
            .to(veilUniforms.u_flash_radius, {
                value: 0.6, // Large radius for the flash
                duration: 0.8,
                ease: "power2.out"
            })
            // Flash in (Hides the revealed area again)
            .to(veilUniforms.u_flash_radius, {
                value: 0.0,
                duration: 0.8,
                ease: "power2.in"
            }, 0.2); // Start retraction slightly delayed

        }
        
        // Random interval between 5 and 15 seconds
        function scheduleNextFlash() {
            const delay = Math.random() * 10 + 5; 
            gsap.delayedCall(delay, triggerRandomFlash);
        }

        // ==========================================
        // 5. GSAP LOADER & TRANSITION SEQUENCE
        // ==========================================
        
        let progress = { value: 0 };
        const kpsiEl = document.getElementById('kpsi-counter');
        const statusEl = document.getElementById('loader-phase');

        const tl = gsap.timeline();

        // --- Part 1: Digital Loom (Loading) ---
        tl.to(progress, {
            value: 100,
            duration: 3.0,
            ease: "power2.inOut",
            onUpdate: function() {
                document.querySelector('.loader-title::after').style.width = (this.progress() * 100) + '%';
                let knots = Math.floor(progress.value * 18);
                kpsiEl.textContent = knots.toString().padStart(4, '0');
                if (progress.value > 30 && progress.value < 60) statusEl.textContent = "WEAVING GEOMETRY";
                if (progress.value > 60 && progress.value < 90) statusEl.textContent = "APPLYING TEXTURES";
                if (progress.value > 90) statusEl.textContent = "FINALIZING MASTERPIECE";
            }
        })
        
        // --- Part 2: Transition to Veil (Instant) ---
        // 1. Hide the Loom UI
        .to("#loader-container", { autoAlpha: 0, duration: 0.5 }, "+=0.3") 
        
        // 2. Camera drops into place (happens *behind* the veil)
        .fromTo(rCamera.position, 
            { y: 40, z: 0, x: 0 },
            { y: 6, z: 3, x: 0, duration: 2.0, ease: "expo.out" }, 
            "<" 
        )
        .fromTo(rCamera.rotation,
            { x: -Math.PI/2 }, 
            { x: -0.8, duration: 2.0, ease: "expo.out" },
            "<"
        )
        
        // 3. Make the UI visible
        .to("#ui-layer", { opacity: 1, duration: 1.0 }, "-=1.0")
        
        // 4. Stagger UI Text appearance
        .from("h1", { y: 50, opacity: 0, duration: 1, ease: "power3.out" }, "-=0.5")
        .from(".hero-desc", { x: -20, opacity: 0, duration: 1 }, "-=0.8")
        .from(".nav-links span", { y: -20, opacity: 0, stagger: 0.1 }, "-=1.0")

        // 5. Start the random flash cycle only after the main animation is done
        .call(scheduleNextFlash);


        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            // Rug Scene Resize
            rCamera.aspect = window.innerWidth / window.innerHeight;
            rCamera.updateProjectionMatrix();
            rRenderer.setSize(window.innerWidth, window.innerHeight);
            // Veil Scene Resize
            vRenderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // --- RUG PARALLAX (Active only after the main intro) ---
        document.addEventListener('mousemove', (e) => {
            const x = (e.clientX / window.innerWidth - 0.5) * 2;
            const y = (e.clientY / window.innerHeight - 0.5) * 2;
            
            if (!tl.isActive()) {
                // Subtle camera/rug movement for depth
                gsap.to(rCamera.position, {
                    x: x * 0.5,
                    y: 6 + y * 0.5,
                    duration: 1
                });
                rCamera.lookAt(0, rug.position.y, 0); // Always look at the rug
            }
        });
    </script>
</body>
</html>